/**
 * Twomiah Care — AES-256-GCM field-level encryption
 *
 * Used for SSN and driver's license numbers stored in the database.
 * Node.js built-in `crypto` module — no extra dependencies required.
 *
 * ⚠️  ENCRYPTION_KEY is auto-generated by Render on first deploy.
 *     Back it up immediately — losing it means losing access to all
 *     encrypted fields. Copy it from Render → Environment → ENCRYPTION_KEY
 *     and store it in your password manager or secrets vault.
 *
 * Stored format:  "<iv_hex>:<authTag_hex>:<ciphertext_hex>"
 * Algorithm:      AES-256-GCM (authenticated encryption, tamper-evident)
 * Key:            32 bytes derived from ENCRYPTION_KEY env var
 */

import { createCipheriv, createDecipheriv, randomBytes, createHash } from 'crypto';

const ALGORITHM = 'aes-256-gcm';

/**
 * Derives a 32-byte Buffer from the ENCRYPTION_KEY env var.
 * Accepts a 64-char hex string (Render auto-generates this format)
 * or any arbitrary string (SHA-256 hashed as fallback).
 */
function getKey() {
  const raw = process.env.ENCRYPTION_KEY;
  if (!raw) {
    throw new Error(
      'ENCRYPTION_KEY environment variable is not set. ' +
      'Cannot encrypt/decrypt sensitive fields.'
    );
  }
  if (/^[0-9a-fA-F]{64}$/.test(raw)) {
    return Buffer.from(raw, 'hex');
  }
  return createHash('sha256').update(raw).digest();
}

/**
 * Encrypts a plaintext string.
 *
 * @param   {string|null|undefined} plaintext
 * @returns {string|null}  "<iv>:<authTag>:<ciphertext>" (hex) or null
 */
export function encrypt(plaintext) {
  if (plaintext == null || plaintext === '') return null;

  const key    = getKey();
  const iv     = randomBytes(12);           // 96-bit IV — recommended for GCM
  const cipher = createCipheriv(ALGORITHM, key, iv);

  const ciphertext = Buffer.concat([
    cipher.update(String(plaintext), 'utf8'),
    cipher.final(),
  ]);
  const authTag = cipher.getAuthTag();      // 16-byte GCM authentication tag

  return [
    iv.toString('hex'),
    authTag.toString('hex'),
    ciphertext.toString('hex'),
  ].join(':');
}

/**
 * Decrypts a ciphertext produced by encrypt().
 *
 * @param   {string|null|undefined} ciphertext  "<iv>:<authTag>:<ct>" hex string
 * @returns {string|null}  plaintext or null if input is null/empty/invalid
 */
export function decrypt(ciphertext) {
  if (ciphertext == null || ciphertext === '') return null;

  try {
    const parts = ciphertext.split(':');
    if (parts.length !== 3) return null;

    const [ivHex, authTagHex, encHex] = parts;
    const key     = getKey();
    const iv      = Buffer.from(ivHex, 'hex');
    const authTag = Buffer.from(authTagHex, 'hex');
    const enc     = Buffer.from(encHex, 'hex');

    const decipher = createDecipheriv(ALGORITHM, key, iv);
    decipher.setAuthTag(authTag);

    return Buffer.concat([
      decipher.update(enc),
      decipher.final(),
    ]).toString('utf8');
  } catch {
    // Decryption failure (wrong key, corrupted data, or tampered ciphertext)
    return null;
  }
}

/**
 * Convenience: return the last 4 chars of a decrypted value for display,
 * e.g. "***-**-1234" style SSN masking without exposing the plaintext.
 *
 * @param   {string|null} ciphertext
 * @param   {number}      [visibleChars=4]
 * @returns {string}      masked string or "—" if null/unreadable
 */
export function maskedDecrypt(ciphertext, visibleChars = 4) {
  const plain = decrypt(ciphertext);
  if (!plain) return '—';
  const digits = plain.replace(/\D/g, '');
  const visible = digits.slice(-visibleChars);
  return `${'•'.repeat(Math.max(0, digits.length - visibleChars))}${visible}`;
}
